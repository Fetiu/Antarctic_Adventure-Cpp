#include"Hole.h"
#include<cmath>
#include<stdlib.h>

const int Hole::form[5][9][11] =
{
	{//첫번째 형태는 항상 행의 인덱스가 3인 지점부터 시작하기. 그래야 배경에서 올바른 위치에 나타남.
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,1,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,5,5,5,0,0,0,0 },
		{ 0,0,0,0,4,4,4,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,5,5,5,0,0,0,0 },
		{ 0,0,0,5,4,4,4,5,0,0,0 },
		{ 0,0,0,0,4,4,4,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
		
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,5,5,5,5,5,0,0,0 },
		{ 0,0,5,4,4,4,4,4,5,0,0 },
		{ 0,0,4,4,4,4,4,4,4,0,0 },
		{ 0,0,0,4,4,4,4,4,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,5,5,5,5,5,5,5,0,0 },
		{ 0,5,4,4,4,4,4,4,4,5,0 },
		{ 0,4,4,4,4,4,4,4,4,4,0 },
		{ 0,0,4,4,4,4,4,4,4,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	}
};

Hole::Hole(const int start_x) :Element(start_x, 0)//10,12,14
{
	this->setStartX(2 * (rand() % 4 + 5));
	//Element(2 * (rand() % 4 + 5), 0);
	shape = 0;
}

void Hole::motionPrint(Output* graphic){
	static int cnt = 0;
	static int num_cnt = 0;

	switch (cnt) {	//기본 모양 한칸씩 내리는거 없애기...그것때문에 제어못하는 경우가 좀 생기는거 같아..
	case 0: 
		shape = 0;
		y = 0;
		break;
	case 1:
		y = 1;
		break;
	case 2:
		shape = 1;//좌표 4는 하지말기
		y = 2;
		break;
	case 3:
		shape = 2;
		y = 3;
		break;
	case 4:
		shape = 2;
		y = 4;
		break;
	case 5:
		shape = 3;
		y = 6;
		break;
	case 6:
		shape = 3;
		y = 8;
		break;
	case 7:
		shape = 4;
		y = 10;
		break;
	case 8:	
		shape = 4;
		y = 13;
		break;
	case 9:
		shape = 4;
		y = 16;
		break;
	case 10:
		shape = 4;
		y = 18;
		cnt = 0;
		break;
	//case 11:
	//	y = 19;
		//y = 3;	//안보이게 
	}
	if (num_cnt % 2)
		cnt++;
	num_cnt++;

	movePos();

	memcpy(presentForm, form[shape%5], sizeof(int) * 9 * 11);//결정된 동작을 현재 형태에 복사
	graphic->fixOnBoard(this);	//출력 보드에 현재 객체 배치. 좌표와 형태 모두 필요.
}

void Hole::movePos() {
	//static int cnt = 0;

	//if (cnt % 3==2)
	//(y > 32) ? y = 3 : y+=2;
	//cnt++;
	float perspect_x ;//,perspect_y;
	static float init_x = x - 13.5;	//|11|12|13|14|15|16|
	static float slope = 8 / init_x;

	if (init_x == 0) {
		init_x = 14;
	}
	else {
		//perspect_y = (float)y;
		perspect_x = (float)(y+3) / slope;//3만큼 평행이동된 함수로 생각해줘야 함.
		x = (int)floor(perspect_x) + 14;	//반올림한뒤 시작점부터의 좌표를 더해줌
	}
}